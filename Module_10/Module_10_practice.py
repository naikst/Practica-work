# Импортируем модуль threading для работы с потоками
import threading
# Импортируем модуль time для работы с временными задержками
import time


# Определяем функцию func1, которая будет выполняться в основном потоке
def func1():
    # Цикл, который выполнится 10 раз
    for i in range(10):
        # Останавливаем выполнение потока на 0.5 секунды
        time.sleep(0.5)
        # Выводим текущее значение i и информацию о текущем потоке
        print(i, threading.current_thread())



# Определяем функцию func2, которая будет выполняться в отдельном потоке
def func2(x):
    # Цикл, который выполнится 10 раз
    for i in range(10):
        # Останавливаем выполнение потока на 1 секунду
        time.sleep(1)
        # Выводим текущее значение i и информацию о текущем потоке
        print(i, threading.current_thread())


# Создаем новый поток, который будет выполнять функцию func2 с аргументом 1
# Параметр daemon=True означает, что поток будет завершен, если завершится основной поток
thread = threading.Thread(target=func2, args=(1,), daemon=True)
# Запускаем созданный поток
thread.start()
# Проверяем, активен ли поток, и выводим результат (True или False)
print(thread.is_alive())
# Вызываем функцию func1, которая будет выполняться в основном потоке
func1()
# Выводим список всех активных потоков
print(threading.enumerate())
# Выводим информацию о текущем потоке (основном потоке)
print(threading.current_thread())