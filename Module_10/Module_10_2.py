# Импортируем необходимые библиотеки для работы с потоками и временем
import threading
import time


# Определяем класс Knight, который наследует от threading.Thread
class Knight(threading.Thread):
    # Инициализируем рыцаря с его именем, силой и блокировкой
    def __init__(self, name, power, lock):
        super().__init__()  # Вызываем конструктор родительского класса, чтобы правильно инициализировать поток
        self.name_full = name  # Сохраняем полное имя рыцаря (например, "Sir Lancelot")
        self.name = name.replace("Sir ", "")  # Сохраняем имя рыцаря без префикса "Sir"
        self.power = power  # Сохраняем силу рыцаря (сколько врагов он убивает за день)
        self.enemies = 100  # Каждый рыцарь начинает с 100 врагов
        self.days = 0  # Счетчик дней сражения (количество дней, которые рыцарь сражался)
        self.lock = lock  # Сохраняем блокировку для синхронизации вывода в консоль

    # Метод run, который будет выполняться, когда поток запущен
    def run(self):
        with self.lock:  # Блокируем вывод для других потоков
            print(f"{self.name_full}, на нас напали!")  # Выводим сообщение об атаке на рыцаря

        # Цикл сражения, который продолжается, пока есть враги
        while self.enemies > 0:
            time.sleep(1)  # Приостанавливаем выполнение на 1 секунду (символизируем день)
            self.enemies -= self.power  # Уменьшаем количество врагов на величину силы рыцаря

            if self.enemies < 0:  # Если количество врагов стало отрицательным
                self.enemies = 0  # Устанавливаем количество врагов на 0 (не может быть меньше нуля)

            self.days += 1  # Увеличиваем счетчик дней сражения

            with self.lock:  # Блокируем вывод для других потоков
                # Выводим текущее состояние сражения (количество дней и оставшиеся враги)
                print(f"{self.name_full}, сражается {self.days} день(дня)..., осталось {self.enemies} воинов.")

            time.sleep(0.1)  # Маленькая задержка, чтобы позволить другому потоку работать

        # Когда все враги побеждены, выводим сообщение о победе
        with self.lock:
            print(f"{self.name_full} одержал победу спустя {self.days} день(дня)!")


# Создаем блокировку для синхронизации потоков
lock = threading.Lock()

# Создаем и запускаем двух рыцарей с разной силой 
knight1 = Knight('Sir Lancelot', 10, lock)  # Первый рыцарь с силой 10
knight2 = Knight('Sir Galahad', 20, lock)  # Второй рыцарь с силой 20
knight1.start()  # Запускаем первого рыцаря в отдельном потоке
knight2.start()  # Запускаем второго рыцаря в отдельном потоке

# Ожидаем завершения сражения обоих рыцарей
knight1.join()  # Ожидаем, пока первый рыцарь завершит свою работу
knight2.join()  # Ожидаем, пока второй рыцарь завершит свою работу

# Выводим сообщение о завершении битвы
print("Битва завершена!")  # Сообщаем, что оба рыцаря завершили свои сражения